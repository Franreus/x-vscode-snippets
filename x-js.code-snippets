{
	// Xavier Visual Studio Code Snippets
	"yargs command": {
		"prefix": "x-yargs1",
		"body": [
			"yargs.command({",
			"    command: '${1:cmd}',",
			"    describe: '${2:txt}',",
			"    builder: {",
			"        ${3:option}: {",
			"            describe: '${4:txt}',",
			"            demandOption: true,",
			"            type: 'string'",
			"        },",
			"        ${5:option}: {",
			"            describe: '${6:example}',",
			"            demandOption: true,",
			"            type: 'string'",
			"        }",
			"    },",
			"    handler(argv) {",
			"        addNote(argv.${3:option}, argv.${5:option})",
			"    }",
			"})"
		],
		"description": "yargs command",
		"scope": "javascript"
	},
	"yargs parse": {
		"prefix": "x-yargs2",
		"body": [
			"yargs.parse()"
		],
		"description": "yargs parse",
		"scope": "javascript"
	},
	"help npm": {
		"prefix": "x-help-npm",
		"body": [
		  "// para generar el package.json",
		  "npm init ",
		  "",
		  "// para instalar los paquetes de package.json",
		  "npm install ",
		  "// para instalar [globalmente] paquetes como devDependencies",
		  "npm install [-g] <paquete> [ --save-dev | -D ]",
		  "// para instalar [globalmente] paquetes como dependencies",
		  "npm uninstall [-g] <paquete>",
		  "",
		  "// para listar [globalmente] paquetes [mostrando lo mínimo]",
		  "npm list [-g] [--depth=0]",
		  "",
		  "// para ejecutar un script de package.json",
		  "npm run <nombre_del_script_en_package.json> ",
		  "",
		  "// ver paquetes desactualizados [globalmente]",
		  "npm outdated [-g] ",
		  "// actualizar [globalmente] un paquete",
		  "npm update [-g] <paquete>",
		  "",
		  "// auditar paquetes [reparar]",
		  "npm audit [fix]"
		],
		"description": "help npm"
	  },
	"mongoose model": {
		"prefix": "x-help-mongoose-model",
		"body": [
			"const mongoose = require('mongoose')",
			"const validator = require('validator')",
			"",
			"const User = mongoose.model('User', {",
			"    name: {",
			"        type: String,",
			"        required: true,",
			"        trim: true",
			"    },",
			"    email: {",
			"        type: String,",
			"        required: true,",
			"        trim: true,",
			"        lowercase: true,",
			"        validate(value) {",
			"            if (!validator.isEmail(value)) {",
			"                throw new Error('Email is invalid')",
			"            }",
			"        }",
			"    },",
			"    password: {",
			"        type: String,",
			"        required: true,",
			"        minlength: 7,",
			"        trim: true,",
			"        validate(value) {",
			"            if (value.toLowerCase().includes('password')) {",
			"                throw new Error('Password cannot contain \"password\"')",
			"            }",
			"        }",
			"    },",
			"    age: {",
			"        type: Number,",
			"        default: 0,",
			"        validate(value) {",
			"            if (value < 0) {",
			"                throw new Error('Age must be a postive number')",
			"            }",
			"        }",
			"    }",
			"})",
			"",
			"module.exports = User"
		],
		"description": "mongoose model"
	},
	"heroku help": {
		"prefix": "x-help-heroku",
		"body": [
		  "heroku -v",
		  "",
		  "heroku login // to start the following",
		  "",
		  "heroku keys:add // to upload id_rsa.pub",
		  "",
		  "heroku create your-awesome-app // to create a heroku app: http and git URL’s created and directly adding git URL into our remotes",
		  "",
		  "heroku git:remote -a your-awesome-app",
		  "",
		  "At package.json:",
		  "\"scripts\": {\"start\": \"node src/app.js\"} // since heroku executes: \"npm run start\"",
		  "",
		  "At app.js: ",
		  "const port = process.env.PORT || 3000   // first set by heroku dynamically, second for our local set up",
		  "",
		  "Delete up to localhost:3000 on URL fetches // using relative paths",
		  "",
		  "Do git add & commit",
		  "",
		  "git push heroku master"
		],
		"description": "heroku help"
	  },
	  "routers/resouce.js": {
		"prefix": "x-routers-resource.js",
		"body": [
		  "const express = require('express')",
		  "const router = new express.Router()",
		  "const ${1:Resource} = require('../models/${2:resource}')",
		  "",
		  "router.post('/${2:resource}s', async (req, res) => {",
		  "    const ${2:resource} = new ${1:Resource}(req.body)",
		  "",
		  "    try {",
		  "        await ${2:resource}.save()",
		  "        res.status(201).send(${2:resource})",
		  "    } catch (e) {",
		  "        res.status(400).send(e)",
		  "    }",
		  "})",
		  "",
		  "router.get('/${2:resource}s', async (req, res) => {",
		  "    try {",
		  "        const ${2:resource}s = await ${1:Resource}.find({})",
		  "        res.send(${2:resource}s)",
		  "    } catch (e) {",
		  "        res.status(500).send()",
		  "    }",
		  "})",
		  "",
		  "router.get('/${2:resource}s/:id', async (req, res) => {",
		  "    const _id = req.params.id",
		  "",
		  "    try {",
		  "        const ${2:resource} = await ${1:Resource}.findById(_id)",
		  "",
		  "        if (!${2:resource}) {",
		  "            return res.status(404).send()",
		  "        }",
		  "",
		  "        res.send(${2:resource})",
		  "    } catch (e) {",
		  "        res.status(500).send()",
		  "    }",
		  "})",
		  "",
		  "router.patch('/${2:resource}s/:id', async (req, res) => {",
		  "    const updates = Object.keys(req.body)",
		  "    const allowedUpdates = ['${3:resource_field_1}', '${4:resource_field_2}']",
		  "    const isValidOperation = updates.every((update) => allowedUpdates.includes(update))",
		  "",
		  "    if (!isValidOperation) {",
		  "        return res.status(400).send({ error: 'Invalid updates!' })",
		  "    }",
		  "",
		  "    try {",
		  "        const ${2:resource} = await ${1:Resource}.findByIdAndUpdate(req.params.id, req.body, { new: true, runValidators: true })",
		  "",
		  "        if (!${2:resource}) {",
		  "            return res.status(404).send()",
		  "        }",
		  "",
		  "        res.send(${2:resource})",
		  "    } catch (e) {",
		  "        res.status(400).send(e)",
		  "    }",
		  "})",
		  "",
		  "router.delete('/${2:resource}s/:id', async (req, res) => {",
		  "    try {",
		  "        const ${2:resource} = await ${1:Resource}.findByIdAndDelete(req.params.id)",
		  "",
		  "        if (!${2:resource}) {",
		  "            res.status(404).send()",
		  "        }",
		  "",
		  "        res.send(${2:resource})",
		  "    } catch (e) {",
		  "        res.status(500).send()",
		  "    }",
		  "})",
		  "",
		  "module.exports = router"
		],
		"description": "routers/resource.js",
		"scope": "javascript"
	  },
	  "ejs out": {
		"prefix": "x-ejsout",
		"body": [
		  "<%= $0 %>"
		],
		"description": "ejs out"
	  },
	  "ejs include": {
		"prefix": "x-ejsinc",
		"body": [
		  "<%- include(\"./partials/${1:filename}.ejs\") %>$0"
		],
		"description": "ejs include"
	  },
	  "ejs": {
		"prefix": "x-ejs",
		"body": [
		  "<% ${1:code} %>$0"
		],
		"description": "ejs"
	  },
	  "html form": {
		"prefix": "x-form",
		"body": [
		  "<form action=\"api/${1:resources}\" method=\"POST\">",
		  "  <label for=\"${2:name}\">${3:label}:</label>",
		  "  <input type=\"text\" id=\"${2:name}\" name=\"${2:name}\" required>",
		  "  <label for=\"${4:name}\">${5:label}:</label>",
		  "  <input type=\"text\" id=\"${4:name}\" name=\"${4:name}\" required>",
		  "  <label for=\"${6:name}\">${7:label}:</label>",
		  "  <textarea id=\"${6:name}\" name=\"${6:name}\" required></textarea>",
		  "  <button>${8:Submit}</button>",
		  "</form>"
		],
		"description": "html form"
	  },
	  "css normalize": {
		"prefix": "x-css-normalize",
		"body": [
		  "* {",
		  "    padding: 0;",
		  "    margin: 0;",
		  "    box-sizing: border-box;",
		  "}",
		  "",
		  "a{",
		  "    text-decoration: none;",
		  "}",
		  "",
		  "ul{",
		  "    list-style-type: none;",
		  "}"
		],
		"description": "css normalize"
	  },
	  "mongoose connection": {
		"prefix": "x-db-mongoose.js",
		"body": [
		  "const mongoose = require('mongoose')",
		  "",
		  "mongoose.connect(process.env.MONGODB_URL, {",
		  "    useNewUrlParser: true,",
		  "    useUnifiedTopology: true,",
		  "    useCreateIndex: true,",
		  "    useFindAndModify: false",
		  "})"
		],
		"description": "mongoose connection",
		"scope": "javascript"
	  },
	  "express app get": {
		"prefix": "x-express-app-get",
		"body": [
		  "app.get('/${1:path}', (req, res) => {",
		  "  res.render('${1:path}', { title: '${2:title}' });",
		  "});"
		],
		"description": "express app get",
		"scope": "javascript"
	  },
	  "express app get all": {
		"prefix": "x-express-app-get-all",
		"body": [
		  "app.get('/${1:path}', async (req, res) => {",
		  "    try {",
		  "        const ${2:model}s = await ${3:Model}.find({})",
		  "        res.render('index', { title: '${4:title}', ${2:model}s });",
		  "    } catch (error) {",
		  "        res.render('index', {title: '${4:title}', ${2:model}s: []})",
		  "    }",
		  "})"
		],
		"description": "express app get all",
		"scope": "javascript"
	  },
	  "express app init": {
		"prefix": "x-express-app-init",
		"body": [
		  "const express = require('express')",
		  "",
		  "require('../db/mongoose')",
		  "const ${1:Model} = require('../models/${2:model}') // optional",
		  "const ${3:router}Router = require('../routers/${3:router}')",
		  "",
		  "const port = process.env.PORT",
		  "",
		  "// express app",
		  "const app = express()",
		  "",
		  "// listen for requests",
		  "app.listen(port, () => {",
		  "  console.log(`Server listening to port \\${port}`)",
		  "})",
		  "",
		  "// register view engine",
		  "app.set('view engine', 'ejs')",
		  "",
		  "// middleware & static files",
		  "app.use(express.static('public'))",
		  "app.use(express.urlencoded({ extended: true }))",
		  "",
		  "// web server",
		  "app.get('/', (req, res) => {",
		  "  res.render('index', { title: 'Home' })",
		  "});",
		  "$0",
		  "",
		  "// api's",
		  "app.use(express.json())",
		  "app.use('/api', ${3:router}Router)",
		  "",
		  "// 404 page",
		  "app.use((req, res) => {",
		  "  res.status(404).render('404', { title: '404' })",
		  "})"
		],
		"description": "express app init",
		"scope": "javascript"
	  },
	  "models/resource.js": {
		"prefix": "x-models-resource",
		"body": [
		  "const mongoose = require('mongoose')",
		  "",
		  "const ${1:Resource} = mongoose.model('${1:Resource}', new mongoose.Schema({",
		  "   ${2:field}: {",
		  "        type: String,",
		  "        ${3:required: true,}",
		  "        ${4:default: '${5:txt}',}",
		  "        ${6:enum: [],}",
		  "        ${7:${8|trim,lowercase,minlength,maxlength|}: true,}",
		  "        ${9:match: ${10:RegExp}},",
		  "        validate(value) {",
		  "            if (!condition) {",
		  "                throw new Error('Condition not met')",
		  "            }",
		  "        }",
		  "    },",
		  "    field: {",
		  "        type: Number,",
		  "        required: true,",
		  "        default: 0,",
		  "        min: 0,",
		  "        max: 0,",
		  "        enum: [],",
		  "        validate(value) {",
		  "            if (!condition) {",
		  "                throw new Error('Condition not met')",
		  "            }",
		  "        }",
		  "    },",
		  "    field: {",
		  "        type: Date,",
		  "        required: true,",
		  "        default: false,",
		  "        min: 0,",
		  "        max: 0,",
		  "        validate(value) {",
		  "            if (!condition) {",
		  "                throw new Error('Condition not met')",
		  "            }",
		  "        }",
		  "    },",
		  "    field: {",
		  "        type: Boolean,",
		  "        required: true,",
		  "        default: false,",
		  "        validate(value) {",
		  "            if (!condition) {",
		  "                throw new Error('Condition not met')",
		  "            }",
		  "        }",
		  "    }",
		  "}))",
		  "",
		  "module.exports = ${1:Resource}"
		],
		"description": "models/resource.js",
		"scope": "javascript"
	  },
	  "css init": {
		"prefix": "x-css-init",
		"body": [
		  "* {",
		  "    padding: 0;",
		  "    margin: 0;",
		  "    box-sizing: border-box;",
		  "}",
		  "",
		  "body {",
		  "    background-color: lightgrey;",
		  "    color: black;",
		  "    width: 80%;",
		  "    margin: auto;",
		  "}",
		  "",
		  "ul {",
		  "    list-style-type: none;",
		  "}",
		  "",
		  "nav li {",
		  "    display: inline-block;",
		  "    margin-left: 16px;",
		  "}",
		  "",
		  "header{",
		  "    margin: 16px;",
		  "    display: flex;",
		  "    justify-content: space-between;",
		  "}",
		  "",
		  "a {",
		  "    text-decoration: none;",
		  "}",
		  "",
		  "label, input, textarea {",
		  "    display: block;",
		  "    margin-bottom: 8px;",
		  "}",
		  "",
		  "main{",
		  "    background-color: lightcyan;",
		  "    border-radius: 16px;",
		  "    margin: 16px;",
		  "    padding: 48px;",
		  "}",
		  "",
		  "footer{",
		  "    margin: 16px;",
		  "}",
		  "",
		  ".post {",
		  "    margin: 16px;",
		  "    padding: 24px;",
		  "    background-color: white;",
		  "    border-radius: 16px;",
		  "}"
		],
		"description": "css 0",
		"scope": "css"
	  },
	  "middleware/auth.js": {
		"prefix": "x-middleware-auth",
		"body": [
		  "const jwt = require('jsonwebtoken')",
		  "const User = require('../models/user')",
		  "",
		  "const auth = async (req, res, next) => {",
		  "    try {",
		  "        const token = req.header('Authorization').replace('Bearer ', '')",
		  "        const decoded = jwt.verify(token, 'secret-key')",
		  "        const user = await User.findOne({ _id: decoded._id, 'tokens.token': token })",
		  "",
		  "        if (!user) {",
		  "            throw new Error()",
		  "        }",
		  "",
		  "        req.token = token",
		  "        req.user = user",
		  "        next()",
		  "    } catch (e) {",
		  "        res.status(401).send({ error: 'Please authenticate.' })",
		  "    }",
		  "}",
		  "",
		  "module.exports = auth"
		],
		"description": "middleware/auth.js",
		"scope": "javascript"
	  },
	  "models/user.js": {
		"prefix": "x-models-user",
		"body": [
		  "const mongoose = require('mongoose')",
		  "const validator = require('validator')",
		  "const bcrypt = require('bcryptjs')",
		  "const jwt = require('jsonwebtoken')",
		  "",
		  "const userSchema = new mongoose.Schema({",
		  "    name: {",
		  "        type: String,",
		  "        required: true,",
		  "        trim: true",
		  "    },",
		  "    email: {",
		  "        type: String,",
		  "        unique: true,",
		  "        required: true,",
		  "        trim: true,",
		  "        lowercase: true,",
		  "        validate(value) {",
		  "            if (!validator.isEmail(value)) {",
		  "                throw new Error('Email is invalid')",
		  "            }",
		  "        }",
		  "    },",
		  "    password: {",
		  "        type: String,",
		  "        required: true,",
		  "        minlength: 7,",
		  "        trim: true,",
		  "        validate(value) {",
		  "            if (value.toLowerCase().includes('password')) {",
		  "                throw new Error('Password cannot contain \"password\"')",
		  "            }",
		  "        }",
		  "    },",
		  "    age: {",
		  "        type: Number,",
		  "        default: 0,",
		  "        validate(value) {",
		  "            if (value < 0) {",
		  "                throw new Error('Age must be a postive number')",
		  "            }",
		  "        }",
		  "    },",
		  "    tokens: [{",
		  "        token: {",
		  "            type: String,",
		  "            required: true",
		  "        }",
		  "    }]",
		  "})",
		  "",
		  "userSchema.methods.generateAuthToken = async function () {",
		  "    const user = this",
		  "    const token = jwt.sign({ _id: user._id.toString() }, 'secret-key')",
		  "",
		  "    user.tokens = user.tokens.concat({ token })",
		  "    await user.save()",
		  "",
		  "    return token",
		  "}",
		  "",
		  "userSchema.statics.findByCredentials = async (email, password) => {",
		  "    const user = await User.findOne({ email })",
		  "",
		  "    if (!user) {",
		  "        throw new Error('Unable to login')",
		  "    }",
		  "",
		  "    const isMatch = await bcrypt.compare(password, user.password)",
		  "",
		  "    if (!isMatch) {",
		  "        throw new Error('Unable to login')",
		  "    }",
		  "",
		  "    return user",
		  "}",
		  "",
		  "// Hash the plain text password before saving",
		  "userSchema.pre('save', async function (next) {",
		  "    const user = this",
		  "",
		  "    if (user.isModified('password')) {",
		  "        user.password = await bcrypt.hash(user.password, 8)",
		  "    }",
		  "",
		  "    next()",
		  "})",
		  "",
		  "const User = mongoose.model('User', userSchema)",
		  "",
		  "module.exports = User"
		],
		"description": "models/user.js",
		"scope": "javascript"
	  },
	  "routers/user.js": {
		"prefix": "x-routers-user",
		"body": [
		  "const express = require('express')",
		  "const User = require('../models/user')",
		  "const auth = require('../middleware/auth')",
		  "const router = new express.Router()",
		  "",
		  "router.post('/users', async (req, res) => {",
		  "    const user = new User(req.body)",
		  "",
		  "    try {",
		  "        await user.save()",
		  "        const token = await user.generateAuthToken()",
		  "        res.status(201).send({ user, token })",
		  "    } catch (e) {",
		  "        res.status(400).send(e)",
		  "    }",
		  "})",
		  "",
		  "router.post('/users/login', async (req, res) => {",
		  "    try {",
		  "        const user = await User.findByCredentials(req.body.email, req.body.password)",
		  "        const token = await user.generateAuthToken()",
		  "        res.send({ user, token })",
		  "    } catch (e) {",
		  "        res.status(400).send()",
		  "    }",
		  "})",
		  "",
		  "router.post('/users/logout', auth, async (req, res) => {",
		  "    try {",
		  "        req.user.tokens = req.user.tokens.filter((token) => {",
		  "            return token.token !== req.token",
		  "        })",
		  "        await req.user.save()",
		  "",
		  "        res.send()",
		  "    } catch (e) {",
		  "        res.status(500).send()",
		  "    }",
		  "})",
		  "",
		  "router.post('/users/logoutAll', auth, async (req, res) => {",
		  "    try {",
		  "        req.user.tokens = []",
		  "        await req.user.save()",
		  "        res.send()",
		  "    } catch (e) {",
		  "        res.status(500).send()",
		  "    }",
		  "})",
		  "",
		  "router.get('/users/me', auth, async (req, res) => {",
		  "    res.send(req.user)",
		  "})",
		  "",
		  "router.get('/users/:id', async (req, res) => {",
		  "    const _id = req.params.id",
		  "",
		  "    try {",
		  "        const user = await User.findById(_id)",
		  "",
		  "        if (!user) {",
		  "            return res.status(404).send()",
		  "        }",
		  "",
		  "        res.send(user)",
		  "    } catch (e) {",
		  "        res.status(500).send()",
		  "    }",
		  "})",
		  "",
		  "router.patch('/users/:id', async (req, res) => {",
		  "    const updates = Object.keys(req.body)",
		  "    const allowedUpdates = ['name', 'email', 'password', 'age']",
		  "    const isValidOperation = updates.every((update) => allowedUpdates.includes(update))",
		  "",
		  "    if (!isValidOperation) {",
		  "        return res.status(400).send({ error: 'Invalid updates!' })",
		  "    }",
		  "",
		  "    try {",
		  "        const user = await User.findById(req.params.id)",
		  "",
		  "        updates.forEach((update) => user[update] = req.body[update])",
		  "        await user.save()",
		  "",
		  "        if (!user) {",
		  "            return res.status(404).send()",
		  "        }",
		  "",
		  "        res.send(user)",
		  "    } catch (e) {",
		  "        res.status(400).send(e)",
		  "    }",
		  "})",
		  "",
		  "router.delete('/users/:id', async (req, res) => {",
		  "    try {",
		  "        const user = await User.findByIdAndDelete(req.params.id)",
		  "",
		  "        if (!user) {",
		  "            return res.status(404).send()",
		  "        }",
		  "",
		  "        res.send(user)",
		  "    } catch (e) {",
		  "        res.status(500).send()",
		  "    }",
		  "})",
		  "",
		  "module.exports = router"
		],
		"description": "routers/user.js",
		"scope": "javascript"
	  },
	  "wrap html": {
		"prefix": "x-wrap-html",
		"body": [
		  "<${1:div}>$TM_SELECTED_TEXT</${1:div}>$0"
		],
		"description": "wrap html"
	  },
	  "wrap ejs": {
		"prefix": "x-wrap-ejs",
		"body": [
		  "<${1:%} $TM_SELECTED_TEXT ${1:%}>$0"
		],
		"description": "wrap html"
	  },
	  "wrap x": {
		"prefix": "x-wrap-x",
		"body": [
		  "${1}$TM_SELECTED_TEXT${2}$0"
		],
		"description": "wrap x"
	  },
	  "array forEach": {
		"prefix": "x-arr-forEach",
		"body": [
		  "${1:array}.forEach((${2:item}${3:, ${4:index}})=>{",
		  "  $0",
		  "})"
		],
		"description": "array forEach",
		"scope": "javascript"
	  },
	  "array map": {
		"prefix": "x-arr-map",
		"body": [
		  "${1:const ${2:newArray} =} ${3:array}.map((${4:item}${5:, ${6:index}})=>{",
		  "  return ${7:newItem}",
		  "})$0"
		],
		"description": "array map",
		"scope": "javascript"
	  },
	  "array filter": {
		"prefix": "x-arr-filter",
		"body": [
		  "${1:const ${2:newArray} =} ${3:array}.filter((${4:item}${5:, ${6:index}})=>{",
		  "  return ${7:key} === ${8:value}",
		  "})$0"
		],
		"description": "array map",
		"scope": "javascript"
	  },
	  "array find": {
		"prefix": "x-arr-find",
		"body": [
		  "${1:const ${2:newArray} =} ${3:array}.find((${4:item}${5:, ${6:index}})=>{",
		  "  return ${7:key} === ${8:value}",
		  "})$0"
		],
		"description": "array find",
		"scope": "javascript"
	  },
	  "array findIndex": {
		"prefix": "x-arr-findIndex",
		"body": [
		  "${1:const ${2:i} =} ${3:array}.findIndex((${4:item}${5:, ${6:index}})=>{",
		  "  return ${7:key} === ${8:value}",
		  "})$0"
		],
		"description": "array findIndex",
		"scope": "javascript"
	  },
	  "array splice": {
		"prefix": "x-arr-splice",
		"body": [
		  "${1:const ${2:newArray} =} ${3:array}.splice(${4:indexToInsert}, ${5:numberToDelete}, ${6:commaSeparatedNewItems})$0"
		],
		"description": "array splice",
		"scope": "javascript"
	  },
	  "array sort": {
		"prefix": "x-arr-sort",
		"body": [
		  "${1:const ${2:arraySorted} =} ${3:array}.sort((${4:item}A, ${4:item})=> {",
		  "    if (${4:item}A && ${4:item}B) {",
		  "        return -1 // to keep",
		  "    } else if (${4:item}A && ${4:item}B) {",
		  "        return 1 // to swap",
		  "    } else {",
		  "        return 0",
		  "    }",
		  "})"
		],
		"description": "array sort"
	  },
	  "arrow function": {
		"prefix": "x-f",
		"body": [
		  "($1) => {",
		  "    $0",
		  "}"
		],
		"description": "arrow function",
		"scope": "javascript"
	  }
}
